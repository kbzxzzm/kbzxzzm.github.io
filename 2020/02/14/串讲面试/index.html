
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>面试经典 - 浮雨博客</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="TriDiamond Obsidian,"> 
    <meta name="description" content="##原生js
1. javascript typeof返会的数据类型有哪些object,string,undefined,number,function,boolean

基本数据类型：string,"> 
    <meta name="author" content="Floating Rain"> 
    <link rel="alternative" href="atom.xml" title="浮雨博客" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link href="https://fonts.loli.net/css?family=Roboto+Mono|Rubik&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="//at.alicdn.com/t/font_1429596_nzgqgvnmkjb.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.7.2/animate.min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/codemirror.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/theme/dracula.css">
    <link rel="stylesheet" href="/css/obsidian.css">
    <link rel="stylesheet" href="/css/ball-atom.min.css">
</head>
</html>

<body class="loading">
    <div class="loader">
        <div class="la-ball-atom la-2x">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
    </div>
    <span id="config-title" style="display:none">浮雨博客</span>
    <div id="loader"></div>
    <div id="single">
    <div class="scrollbar gradient-bg-rev"></div>
<div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <div class="navigation animated fadeIn fast delay-1s">
        <img id="home-icon" class="icon-home" src="/img/favicon.png" alt="" data-url="https://kbzxzzm.github.io">
        <div id="play-icon" title="Play/Pause" class="iconfont icon-play"></div>
        <h3 class="subtitle">面试经典</h3>
        <div class="social">
            <!--        <div class="like-icon">-->
            <!--            <a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
            <!--        </div>-->
            <div>
                <div class="share">
                    
                        <a href="javascript:;" class="iconfont icon-share1"></a>
                        <div class="share-component-cc" data-disabled="facebook,douban,linkedin,diandian,tencent,google"></div>
                    
                </div>
            </div>
        </div>
    </div>
</div>

    <div class="section">
        <div class=article-header-wrapper>
    <div class="article-header">
        <div class="article-cover animated fadeIn" style="
            animation-delay: 600ms;
            animation-duration: 1.2s;
            background-image: 
                radial-gradient(ellipse closest-side, rgba(0, 0, 0, 0.65), #100e17),
                url(https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1100806427,1038533635&fm=15&gp=0.jpg);">
        </div>
        <div class="else">
            <p class="animated fadeInDown">
                
                <a href="javascript:;"><b>「 </b>文章<b> 」</b></a>
                
                二月 14, 2020
            </p>
            <h3 class="post-title animated fadeInDown"><a href="/2020/02/14/串讲面试/" title="面试经典">面试经典</a>
            </h3>
            
            <p class="post-count animated fadeInDown">
                
                <span>
                    <b class="iconfont icon-text2"></b> <i>文章字数</i>
                    49k
                </span>
                
                
                <span>
                    <b class="iconfont icon-timer__s"></b> <i>阅读约需</i>
                    45 mins.
                </span>
                
                
                
                <span id="busuanzi_container_page_pv">
                    <b class="iconfont icon-read"></b> <i>阅读次数</i>
                    <span id="busuanzi_value_page_pv">0</span>
                </span>
                
            </p>
            
            
        </div>
    </div>
</div>

<div class="screen-gradient-after">
    <div class="screen-gradient-content">
        <div class="screen-gradient-content-inside">
            <div class="bold-underline-links screen-gradient-sponsor">
                <p>
                    <span class="animated fadeIn delay-1s"></span>
                </p>
            </div>
        </div>
    </div>
</div>

<div class="article">
    <div class='main'>
        <div class="content markdown animated fadeIn">
            <p>##原生js</p>
<h2 id="1-javascript-typeof返会的数据类型有哪些"><a href="#1-javascript-typeof返会的数据类型有哪些" class="headerlink" title="1. javascript typeof返会的数据类型有哪些"></a>1. javascript typeof返会的数据类型有哪些</h2><p>object,string,undefined,number,function,boolean</p>
<blockquote>
<p>基本数据类型：<br>string,number,boolean,undefined,null</p>
<p>复杂数据类型</p>
<p>object 数组  对象 </p>
<p>基本类型 和复杂类型 赋值区别是什么？比如 a 赋值给 b </p>
<p>基本类型 赋值 是整个值 复制一份 他赋值后  不是同一个了 只是值一样而已</p>
<p>复杂类型  赋值  是复制 地址  指向同一个空间  修改的还是同一个 </p>
</blockquote>
<h2 id="2-列举三种强制类型转换-显示转换-和两种隐式类型转换"><a href="#2-列举三种强制类型转换-显示转换-和两种隐式类型转换" class="headerlink" title="2. 列举三种强制类型转换(显示转换)和两种隐式类型转换"></a>2. 列举三种强制类型转换(显示转换)和两种隐式类型转换</h2><p>parseInt(),parseFloat(),Number()<br>==,!!</p>
<h2 id="3-数组"><a href="#3-数组" class="headerlink" title="3. 数组"></a>3. 数组</h2><h2 id="4-判断是否为数组的方法"><a href="#4-判断是否为数组的方法" class="headerlink" title="4. 判断是否为数组的方法"></a>4. 判断是否为数组的方法</h2><ul>
<li>console.log(arr instanceof Array)</li>
<li>console.log(Array.isArray(arr))</li>
<li>console.log(Object.prototype.toString.call(arr)</li>
</ul>
<h2 id="5-pop-push-unshift-shift"><a href="#5-pop-push-unshift-shift" class="headerlink" title="5. pop(),push(),unshift(),shift()"></a>5. pop(),push(),unshift(),shift()</h2><ul>
<li>pop()尾部删除</li>
<li>push()尾部插入</li>
<li>unshift()头部插入</li>
<li>shift()头部删除</li>
</ul>
<h2 id="6-DOM0-DOM2"><a href="#6-DOM0-DOM2" class="headerlink" title="6. DOM0 DOM2"></a>6. DOM0 DOM2</h2><p>dom0级</p>
<ul>
<li>不支持添加多个事件，后面的会覆盖前面的</li>
<li>无法取消</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var btn = document.getElementById(&quot;button&quot;);</span><br><span class="line">btn.onclick = function()&#123;</span><br><span class="line">    alert(1);</span><br><span class="line">&#125;</span><br><span class="line">btn.onclick = function()&#123;</span><br><span class="line">    alert(2);</span><br><span class="line">&#125;       //只弹出2</span><br></pre></td></tr></table></figure>

<p>dom2</p>
<ul>
<li>可以添加多个事件</li>
<li>不兼容低版本IE</li>
<li>支持事件冒泡，事件捕获</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var btn = document.getElementById(&quot;button&quot;);</span><br><span class="line">btn.addEventListener(&quot;click&quot;,function()&#123;</span><br><span class="line">    alert(&quot;1&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">btn.addEventListener(&quot;click&quot;,function()&#123;</span><br><span class="line">    alert(&quot;2&quot;);</span><br><span class="line">&#125;)              //先弹出1，再弹出2</span><br></pre></td></tr></table></figure>

<h2 id="7-IE678很多兼容问题-大家找两个记一下"><a href="#7-IE678很多兼容问题-大家找两个记一下" class="headerlink" title="7. IE678很多兼容问题(大家找两个记一下 )"></a>7. IE678很多兼容问题(大家找两个记一下 )</h2><h2 id="8-IE标准下有哪些兼容性写法"><a href="#8-IE标准下有哪些兼容性写法" class="headerlink" title="8. IE标准下有哪些兼容性写法"></a>8. IE标准下有哪些兼容性写法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var ev = ev||window.event</span><br><span class="line"></span><br><span class="line">document.documentElement.clientWidth||document.body.clientWidth</span><br><span class="line"></span><br><span class="line">var target = ev.srcElement||ev.target</span><br></pre></td></tr></table></figure>

<h2 id="9-call-apply-bind"><a href="#9-call-apply-bind" class="headerlink" title="9. call apply bind"></a>9. call apply bind</h2><p>改变this的指向， call apply立刻执行  bind 返回函数  call 参数顺序写  apply参数 是数组</p>
<h2 id="10-构造函数"><a href="#10-构造函数" class="headerlink" title="10. 构造函数"></a>10. 构造函数</h2><h2 id="11-如何阻止默认行为和事件冒泡"><a href="#11-如何阻止默认行为和事件冒泡" class="headerlink" title="11. 如何阻止默认行为和事件冒泡"></a>11. 如何阻止默认行为和事件冒泡</h2><ul>
<li>return false,  阻止默认行为</li>
<li>event.preventDefault, 阻止默认行为</li>
<li>event.stopPropagation()  阻止冒泡</li>
<li>cancelBubble(IE), 阻止冒泡</li>
</ul>
<h2 id="12-添加-删除-替换-插入到某个DOM节点的方法"><a href="#12-添加-删除-替换-插入到某个DOM节点的方法" class="headerlink" title="12. 添加 删除 替换 插入到某个DOM节点的方法"></a>12. 添加 删除 替换 插入到某个DOM节点的方法</h2><ul>
<li>obj.appendChild()  </li>
<li>A.insertBefore(C)</li>
<li>obj.replace()</li>
<li>obj.remove()</li>
</ul>
<h2 id="13-window-onload和-document-ready的区别"><a href="#13-window-onload和-document-ready的区别" class="headerlink" title="13. window.onload和$(document).ready的区别"></a>13. window.onload和$(document).ready的区别</h2><ul>
<li>window.onload只能出现一次，$(document).ready       能出现多次  </li>
<li>$(function(){    })    是ready的简写</li>
<li>window.onload 需要等所有文件都加载完才开始加载 比如图片需要等着加载完，$(document).ready只需等文档结构加载完了就开始加载</li>
</ul>
<h2 id="14-和-区别"><a href="#14-和-区别" class="headerlink" title="14. == 和 === 区别"></a>14. == 和 === 区别</h2><p>==  比较值</p>
<p>=== 比较值 类型</p>
<h2 id="15-javascript的同源策略（跨域问题）"><a href="#15-javascript的同源策略（跨域问题）" class="headerlink" title="15. javascript的同源策略（跨域问题）"></a>15. javascript的同源策略（跨域问题）</h2><p>跨域是什么：实际上就是一个网站不能执行其他网站上的网址，是由浏览器同源策略造成的，是浏览器对js施加的安全限制<br>所谓同源，实际上是指域名，协议，端口都相同<br>也就是说当，域名或者协议，或者端口不同的时候，就是跨域，</p>
<h3 id="15-1-解决方法："><a href="#15-1-解决方法：" class="headerlink" title="15.1. 解决方法："></a>15.1. 解决方法：</h3><p><strong>jsonp</strong></p>
<p>json with padding,是一种json的一种使用模式<br>产生的原因，ajax不支持跨域，由于浏览器的同源策略，但是script的src支持跨域<br>主要的原理是动态创建一个script标签的，通过src调用服务器提供的js脚本，该脚本的内容是一个函数调用，该函数在本地js文件中进行定义，其中的参数就是，本地函数请求的数据，也就是服务器所将返回的数据</p>
<p>与ajax的不同，ajax是通过xhr获取非本页面的数据内容，而jsonp获取的是服务器提供js脚本</p>
<p><strong>jsonp 缺点：</strong> 不安全  只能发get</p>
<p><strong>cros 跨域资源共享</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在服务器 设置头部 允许跨域</span><br><span class="line">header(&apos;Access-Control-Allow-Origin:*&apos;);//允许所有来源访问</span><br><span class="line"></span><br><span class="line">header(&apos;Access-Control-Allow-Method:POST,GET&apos;);//允许访问的方式</span><br></pre></td></tr></table></figure>

<p><strong>反向代理</strong></p>
<ul>
<li>例如<a href="http://www.123.com/index.html需要调用" target="_blank" rel="noopener">www.123.com/index.html需要调用</a></li>
<li><a href="http://www.456.com/server.php，可以写一个接口" target="_blank" rel="noopener">www.456.com/server.php，可以写一个接口</a></li>
<li><a href="http://www.123.com/server.php，由这个接口在后端去调用" target="_blank" rel="noopener">www.123.com/server.php，由这个接口在后端去调用</a></li>
<li><a href="http://www.456.com/server.php并拿到返回值，然后再返回给" target="_blank" rel="noopener">www.456.com/server.php并拿到返回值，然后再返回给</a> index.html，这就是一个代理的模式。相当于绕过了浏览器端，自然就不存在跨域问题。</li>
</ul>
<h2 id="16-javascript是一种什么样的语言"><a href="#16-javascript是一种什么样的语言" class="headerlink" title="16. javascript是一种什么样的语言"></a>16. javascript是一种什么样的语言</h2><ul>
<li>解释性脚本语言，代码不进行预编译</li>
<li>主要用来向HTML页面添加交互行为</li>
<li>可以直接嵌入HTML页面，但单独写成js文件有利于结构和行为的分离</li>
<li>跨平台性，在绝大多数浏览器支持下，可以在多种平台下运行，linux,windows</li>
</ul>
<h2 id="17-javascript基本数据类型和引用数据类型-复杂类型"><a href="#17-javascript基本数据类型和引用数据类型-复杂类型" class="headerlink" title="17. javascript基本数据类型和引用数据类型(复杂类型)"></a>17. javascript基本数据类型和引用数据类型(复杂类型)</h2><blockquote>
<p>基本类型 undefind null number string boolean</p>
</blockquote>
<ul>
<li>基本类型的值是不能改变的</li>
<li>基本类型不能添加属性和方法</li>
<li>基本类型的比较是值的比较</li>
<li>基本类型变量存放在栈区（栈内存）</li>
<li>也就是说基本类型在赋值操作后，两个变量是相互不受影响的。</li>
</ul>
<blockquote>
<p>引用类型 object Function Array</p>
</blockquote>
<ul>
<li>引用类型可以添加属性和方法，属性方法内又可以添加基本类型</li>
<li>引用类型的值是可变的</li>
<li>引用类型的值时同时保存在栈内存和堆内存里的对象，准确地说，引用类型的存储需要内存的栈区和堆区（堆区是指内存里的堆内存）共同完成，栈区内存保存变量标识符和指向堆内存中该对象的指针，</li>
<li>引用类型的比较是引用的比较 引用类型时按引用访问的，换句话说就是比较两个对象的堆内存中的地址是否相同，那很明显，person1和person2在堆内存中地址是不同的</li>
<li>引用类型的赋值其实是对象保存在栈区地址指针的赋值，因此两个变量指向同一个对象，任何的操作都会相互影响</li>
</ul>
<h2 id="18-js原生不要与jq搞混"><a href="#18-js原生不要与jq搞混" class="headerlink" title="18. js原生不要与jq搞混"></a>18. js原生不要与jq搞混</h2><ul>
<li>document.getELementById(“ID”).value</li>
</ul>
<p>获取值的时候原生不是方法，不带括号</p>
<ul>
<li>获取所有checkbox</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var boxs =document.getELementsByTagName(&quot;input&quot;);</span><br><span class="line">var boxArray = [];</span><br><span class="line">var len = boxs.length;</span><br><span class="line">while(len--)&#123;</span><br><span class="line">    if(boxs[len].type == &apos;checkbox&apos;)&#123;</span><br><span class="line">        boxArray.push(boxs[len]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置div html内容以及设置样式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var dom = document.getElementById(&quot;ID&quot;);</span><br><span class="line">dom.innerHTML = &quot;xxxx&quot;</span><br><span class="line">dom.style.color=&quot;#000&quot;</span><br><span class="line"></span><br><span class="line">innerHTML 设置标签字符串 会转成标签</span><br><span class="line">innerText  是文本 不会解析</span><br></pre></td></tr></table></figure>

<h2 id="19-DOM-BOM"><a href="#19-DOM-BOM" class="headerlink" title="19. DOM,BOM"></a>19. DOM,BOM</h2><p>javascript由ECMAScript,DOM,BOM三部分组成，</p>
<ul>
<li>ECMAScript也是一种语言，也就是对规定的语法，操作，关键字，语句等的一个描述，javascript实现了ECMAScript</li>
<li>DOM是文档对象模型，包括了获取元素，修改样式，操作元素三方面内容，也是我们进行最多的操作，有很多兼容性写法</li>
<li>BOM是浏览器对象模型，包括浏览器的一些操作，window.onload,window.open等还有浏览器事件，监听窗口的改变onresize,监听滚动事件onscroll等</li>
</ul>
<h2 id="20-null和undefind的区别"><a href="#20-null和undefind的区别" class="headerlink" title="20. null和undefind的区别"></a>20. null和undefind的区别</h2><ul>
<li>null是表示一个空的对象，转为数值为0，undefind表示一个空的原始值，转为数值为NAN</li>
<li>undefind指本该有一个值，但却并有定义，null表示没有对象，不应该有值</li>
</ul>
<h2 id="21-XML和JSON的区别"><a href="#21-XML和JSON的区别" class="headerlink" title="21. XML和JSON的区别"></a>21. XML和JSON的区别</h2><ul>
<li>JSON相对于XML来讲传递速度更快，因为光看代码量就能看出</li>
<li>JSON与js的交互更容易，解析更方便</li>
<li>JSON 严格 字符串必须有双引号</li>
</ul>
<h2 id="22-前端存储"><a href="#22-前端存储" class="headerlink" title="22. 前端存储"></a>22. 前端存储</h2><p>调用localStorage,cookies等本地存储进行存储相关信息<br>三者的共同点：都保存在浏览器。<br>三者的区别：</p>
<blockquote>
<p>与服务器的交互 cookie一直都会发送   sessionStorage和localStorage 不会发送</p>
</blockquote>
<ul>
<li>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。</li>
<li>而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。</li>
</ul>
<blockquote>
<p>存储大小限制也不同，</p>
</blockquote>
<ul>
<li>cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。</li>
<li>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li>
</ul>
<blockquote>
<p>数据有效期不同，</p>
</blockquote>
<ul>
<li>sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；</li>
<li>localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；</li>
<li>cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。</li>
</ul>
<blockquote>
<p>作用域不同，</p>
</blockquote>
<ul>
<li><p>sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；</p>
</li>
<li><p>localStorage 在所有同源窗口中都是共享的；</p>
</li>
<li><p>cookie也是在所有同源窗口中都是共享的。</p>
<p><strong>session</strong>   : 后端设置  存在服务器中  比较安全</p>
</li>
</ul>
<h2 id="23-哪些操作会造成内存泄露"><a href="#23-哪些操作会造成内存泄露" class="headerlink" title="23. 哪些操作会造成内存泄露"></a>23. 哪些操作会造成内存泄露</h2><blockquote>
<p>内存泄露指任何对象在不再拥有或不再需要它之后依然存在</p>
</blockquote>
<ul>
<li>setTimeout 定时器 延时器  要记得 清除</li>
<li>闭包</li>
<li>控制台日志</li>
<li>循环（两个对象彼此引用且彼此保留）</li>
</ul>
<h2 id="24-js垃圾回收方式"><a href="#24-js垃圾回收方式" class="headerlink" title="24. js垃圾回收方式"></a>24. js垃圾回收方式</h2><ul>
<li><p>标记清除：这是js最常用的垃圾回收方法，当一个变量进入执行环境时，例如函数中声明一个变量，将其标记为进入环境，当变量离开环境时，（函数执行结束），标记为离开环境</p>
</li>
<li><p>引用计数: 跟踪记录每个值被引用的次数，声明一个变量，并将引用 类型赋值给这个变量，则这个值的引用次数+1，当变量的值变成了另一个，则这个值的引用次数-1，当值的引用次数为0的时候，就回收</p>
<p>如果 用完的数据 没有回收  越来越多的占用着内存 就会造成内存泄漏</p>
</li>
</ul>
<h2 id="25-闭包"><a href="#25-闭包" class="headerlink" title="25. 闭包"></a>25. 闭包</h2><ul>
<li>函数嵌套函数</li>
<li>子级函数调用父级函数的参数或变量</li>
</ul>
<p><strong>经典闭包</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function outer()&#123;</span><br><span class="line">    var a = 1;</span><br><span class="line">    function inner()&#123;</span><br><span class="line">        alert(a);</span><br><span class="line">    &#125;</span><br><span class="line">    return inner</span><br><span class="line">&#125;</span><br><span class="line">var inn = outer();</span><br><span class="line">inn();</span><br></pre></td></tr></table></figure>

<p><strong>点击li返回li下标</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;test&quot;&gt;</span><br><span class="line">    &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var oUL = document.getElementById(&quot;test&quot;);</span><br><span class="line">    var oLi = oUl.getElementByTagName(&quot;li&quot;);</span><br><span class="line">    for(var i=0;i&lt;oLi.length;i++)&#123;</span><br><span class="line">        oLi[i].index = i;</span><br><span class="line">        oLi[i].onclick = function()&#123;</span><br><span class="line">            alert(this.index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 闭包 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var oUL = document.getElementById(&quot;test&quot;);</span><br><span class="line">    var oLi = oUl.getElementByTagName(&quot;li&quot;);</span><br><span class="line">    for(var i=0;i&lt;oLi.length;i++)&#123;</span><br><span class="line">        oLi[i].index = i;</span><br><span class="line">        oLi[i].onclick = (function(a)&#123;</span><br><span class="line">            return function()&#123;</span><br><span class="line">                alert a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="26-this指向问题"><a href="#26-this指向问题" class="headerlink" title="26. this指向问题"></a>26. this指向问题</h2><blockquote>
<p>普通函数调用，指向windows</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.value=1;</span><br><span class="line">function getValue()&#123;</span><br><span class="line"> console.log(this.value);</span><br><span class="line">&#125;</span><br><span class="line">getValue();//输出1，此时的this指向window</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对象的方法调用，指向对象</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var Obj=&#123;</span><br><span class="line">  value:2,</span><br><span class="line">  getValue:function()&#123;</span><br><span class="line">       console.log(this.value);//输出2,this指向Obj</span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>构造器方法调用，指向构造函数实例出来的对象</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function main(val)&#123;</span><br><span class="line">  this.value=val;</span><br><span class="line">&#125;</span><br><span class="line">main.prototype.getValue=function()&#123;</span><br><span class="line">  console.log(this.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fun=new main(3);</span><br><span class="line">fun.getValue();</span><br><span class="line">fun.value;//输出3，this指向main的实例对象fun</span><br></pre></td></tr></table></figure>

<blockquote>
<p>call,apply,bind可以自定义this指向第一个参数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function showValue()&#123;</span><br><span class="line">  console.log(this.value);</span><br><span class="line">&#125;</span><br><span class="line">var obj=&#123;</span><br><span class="line">  value:4</span><br><span class="line">&#125;</span><br><span class="line">showValue.call(obj)//输出4，this指向了obj对象</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function showValue()&#123;</span><br><span class="line">  console.log(this.value);</span><br><span class="line">&#125;</span><br><span class="line">var obj=&#123;</span><br><span class="line">  value:4</span><br><span class="line">&#125;</span><br><span class="line">var showValue2=showValue.bind(obj);</span><br><span class="line">showValue2()//输出4，this指向了obj对象</span><br></pre></td></tr></table></figure>

<h2 id="27-高阶函数"><a href="#27-高阶函数" class="headerlink" title="27. 高阶函数"></a>27. 高阶函数</h2><ul>
<li>函数作为参数传递，</li>
<li>函数作为返回值输出</li>
</ul>
<h2 id="28-new操作符到底干了什么"><a href="#28-new操作符到底干了什么" class="headerlink" title="28. new操作符到底干了什么"></a>28. new操作符到底干了什么</h2><ul>
<li>开辟一个新空间创建一个新对象 </li>
<li>将构造函数的作用域赋值给新对象（就是 this指向了这个新对象）</li>
<li>执行构造函数的代码（为这个新对象添加属性）</li>
<li>返会新对象</li>
</ul>
<h2 id="29-js严格模式"><a href="#29-js严格模式" class="headerlink" title="29. js严格模式"></a>29. js严格模式</h2><p>“use strict”<br>消除js一些不合理的用法<br>消除代码运行的一些不安全之处<br>增加运行速度<br>为未来新版本js做铺垫(现在我们就写es6)</p>
<ul>
<li>变量必须声明</li>
<li>对象不能出现重复属性名</li>
<li>arguments改变，不会影响函数参数</li>
<li>eval，arguments变为关键字，不能作为变量名</li>
<li>不允许使用with</li>
<li>不用call，apply，bind改变this指向，一般函数调用指向undefined</li>
</ul>
<h2 id="30-事件代理事件委托"><a href="#30-事件代理事件委托" class="headerlink" title="30. 事件代理事件委托"></a>30. 事件代理事件委托</h2><ul>
<li>原理是使用dom的冒泡，将事件绑定到父元素上，让父元素进行监听，提高性能</li>
</ul>
<h2 id="31-什么是版本控制，"><a href="#31-什么是版本控制，" class="headerlink" title="31.什么是版本控制，"></a>31.什么是版本控制，</h2><p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅修改以及更新。</p>
<p>git  svn等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git init -y  初始化仓库</span><br><span class="line">git add .   添加代码</span><br><span class="line">git commit -m &apos;完成了登录功能&apos;  提交代码</span><br><span class="line"></span><br><span class="line">git push 地址 分支  把本地代码 推送到 远程服务器 (把我的代码 推送 发给老大)</span><br></pre></td></tr></table></figure>

<h2 id="32-ajax请求"><a href="#32-ajax请求" class="headerlink" title="32.ajax请求"></a>32.ajax请求</h2><ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 1 new 一个xhr对象</span><br><span class="line">    let xhr=new XMLHttpRequest()</span><br><span class="line">    // 2 open 创建请求</span><br><span class="line">    xhr.open(&apos;get/post&apos;,接口地址)</span><br><span class="line">    // xhr.setRequestHeader(&quot;content-type&quot;,&quot;application/x-www-formdata&quot;)</span><br><span class="line">    // 3 send 发送请求</span><br><span class="line">    xhr.send(null或者&apos;name=zs&amp;age=18&apos;)</span><br><span class="line">    // 4 监听请求成功的函数</span><br><span class="line">    xhr.onreadystatechange=function()&#123;</span><br><span class="line">        if(xhr.status===200&amp;&amp;xhr.readyState===4)&#123;// 成功了并且数据可以用了</span><br><span class="line">            console.log(xhr.responseText) ;//接受正常值</span><br><span class="line">            // xhr.responseXML  专门接受xml数据</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ajax  get 和post的区别？</span><br><span class="line">    // 1  参数写在哪？get 写在 ul地址?name=zs&amp;age=18  post 写在send里面</span><br><span class="line">    // 2  需要请求头吗? get 不需要  post需要写xhr.setRequestHeader</span><br><span class="line">    // 3 send 是get 可以写null  post参数写在send这里</span><br><span class="line"></span><br><span class="line">    // 进度条   </span><br><span class="line">    // xhr.upload.onprogress=function(e)&#123;</span><br><span class="line">    //   // 这里可以算 上传了 比如视频  百分之多少的</span><br><span class="line">    //   //  e.total  总大小  100M</span><br><span class="line">    //   //  e.loaded  上次了多少  50M</span><br><span class="line">    // &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="33-在浏览器中输入URL到整个页面显示在用户面前时这个过程中到底发生了什么"><a href="#33-在浏览器中输入URL到整个页面显示在用户面前时这个过程中到底发生了什么" class="headerlink" title="33.在浏览器中输入URL到整个页面显示在用户面前时这个过程中到底发生了什么"></a>33.在浏览器中输入URL到整个页面显示在用户面前时这个过程中到底发生了什么</h2><ul>
<li>浏览器输入域名 <a href="http://www.taobao.com" target="_blank" rel="noopener">www.taobao.com</a></li>
<li>DNS解析 成对应的ip地址</li>
<li>TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ul>
<h3 id="详细："><a href="#详细：" class="headerlink" title="详细："></a>详细：</h3><p>首先根据url中的域名，在远程服务器中查询对应</p>
<h2 id="34-ajax和json"><a href="#34-ajax和json" class="headerlink" title="34.ajax和json"></a>34.ajax和json</h2><blockquote>
<p>ajax用于web页面中实现异步数据交互，实现页面局部内容刷新</p>
</blockquote>
<ul>
<li>优点：能够进行内容局部加载刷新，减少带宽，避免用户不断刷新以及页面跳转，提高用户体验</li>
<li>缺点：对搜索引擎不友好；浏览器不支持ajax的后退；</li>
</ul>
<blockquote>
<p>json是一种请求轻量级的数据交互格式</p>
</blockquote>
<ul>
<li>优点：轻量级，便于人的阅读理解，便于机器解析</li>
</ul>
<h2 id="35-http考点"><a href="#35-http考点" class="headerlink" title="35.http考点"></a>35.http考点</h2><h3 id="常用的HTTP方法有哪些"><a href="#常用的HTTP方法有哪些" class="headerlink" title="常用的HTTP方法有哪些"></a>常用的HTTP方法有哪些</h3><p>GET: 用来获取<br>POST: 提交数据<br>PUT:  修改数据<br>DELETE:  删除数据</p>
<p>$.ajax( {type:”delete”})</p>
<p>平时我们 用get 和post就可以了  但是有些公司四个都会</p>
<h3 id="GET与POST方法的区别"><a href="#GET与POST方法的区别" class="headerlink" title="GET与POST方法的区别"></a>GET与POST方法的区别</h3><ul>
<li>get主要是从服务器获取资源，post主要是像服务器发送数据</li>
<li>get传输数据通过url请求，利用k=v的形式放在url后面，用?连接，多个用&amp;连接而post是存放在，ajax中的data中的，get传输的过程使用户可见 的，而post是对用户不可见的。</li>
<li>get传输的数据量小，因为受url的长度限制，但是效率高，post能上传的数据量大</li>
<li>post较get更安全一些</li>
<li>get方式传递的中文字符可能会乱码，post支持标准字符集，可以正确传递中文字符</li>
</ul>
<h3 id="http请求报文与响应报文格式"><a href="#http请求报文与响应报文格式" class="headerlink" title="http请求报文与响应报文格式"></a>http请求报文与响应报文格式</h3><p>请求报文包含三部分：</p>
<ul>
<li>请求行：包含请求方法、URI、http版本信息</li>
<li>请求头</li>
<li>请求内容实体</li>
</ul>
<p>响应报文包含三部分：</p>
<ul>
<li>状态行：包含HTTP版本、状态码、状态码的原因短语</li>
<li>响应头</li>
<li>响应内容实体</li>
</ul>
<h3 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h3><ul>
<li>100-199：成功接收请求，但需要进行下一步请求</li>
<li>200-299：成功接收请求，并完成整个处理过程</li>
<li>300-399：为完成全部请求，客户需近一步细化需求</li>
<li>400-499：客户端请求有错误，包括语法错误或不能正常执行</li>
<li>500-599：服务器端出现错误</li>
</ul>
<h3 id="http缺点与https"><a href="#http缺点与https" class="headerlink" title="http缺点与https"></a>http缺点与https</h3><ul>
<li>通信使用明文不加密，内容可能被窃听</li>
<li>不验证通信方身份，可能遭到伪装</li>
<li>无法验证报文完整性，可能被篡改</li>
</ul>
<p>https就是加上加密处理（一般是SSL安全通信线路）+认证+完整性保护</p>
<p><strong>如果一个网站是  http  需要改成http是 怎么做呢？</strong></p>
<p>​        申请ssl 证书  放到 你的服务器  那么 就是 https了  他就会加密</p>
<p><strong>常用状态码</strong>：</p>
<ul>
<li>200 正常成功，表示一切正常，返会的是正常请求结果</li>
<li>302/307 临时重定向（重新跳转到其他页面），表示请求的文档，已被临时移动到别处</li>
<li>304 未修改，调用缓存的数据</li>
<li>403 服务器拒绝客户请求 禁止访问 forbid</li>
<li>404 服务器不存在客户想要找的资源  没找到 地址错了 not found</li>
<li>500 服务器内部错误 </li>
</ul>
<h1 id="es6"><a href="#es6" class="headerlink" title="es6"></a>es6</h1><blockquote>
<p>let const</p>
</blockquote>
<ul>
<li>let相当于给js新增了块级作用域，声明的变量只在let命令所在的代码块内有效</li>
<li>const 也是声明常量 ，值声明了就不能改变，可以用来声明第三方库变量的应用</li>
</ul>
<blockquote>
<p>class extends super</p>
</blockquote>
<ul>
<li>class定义一个类，其中有一个construct方法，construct方法中的this代表实例对象，construct以外还有其他的方法，construct内定义的方法属性是实例对象自己的，construct外的方法属性是所有实例对象共享的</li>
<li>class之间可以通过extends实现继承</li>
<li>super指代父类的实例，子类construct中必须先调用super()方法，因为子类没有自己的this对象，是继承父类的this对象</li>
</ul>
<blockquote>
<p>arrow function(箭头函数)  ()=&gt;{}</p>
</blockquote>
<p>除了书写简洁了很多，最大的优点是this指向，使用箭头函数，函数内部的this就是定义时所在的对象。箭头函数根本没有自己的this，this是继承外面的，它内部的this就是外层代码块的this</p>
<blockquote>
<p>template string(模板字符串)</p>
</blockquote>
<p>ajax调用数据库，需要向文档中插入大段html的时候，传统的字符串拼接太麻烦，引入模板工具库会稍微好点，不过还是没有es6的template string简单，可以直接用反单引号包括代码块``,用${}来引用变量，所有的空格缩进都会保留到输出中</p>
<blockquote>
<p>destructuring(解构赋值)</p>
</blockquote>
<p>es6按照一定模式，从数组和对象中提取值，对变量进行赋值，这就成为解构，也就是说，运用es5的方法，数组和对象中的变量需要，一个个进行赋值，而es6可以一步到位</p>
<blockquote>
<p>default,rest(默认值，扩展语法)</p>
</blockquote>
<p>当函数忘记传参的时候，给它一个默认值，传统方法是在函数中运用||，es6可以直接在参数中写上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function animal(type)&#123;</span><br><span class="line">    type = type || &apos;cat&apos;  </span><br><span class="line">    console.log(type)</span><br><span class="line">&#125;</span><br><span class="line">animal()</span><br><span class="line">function animal(type = &apos;cat&apos;)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>·箭头函数</strong> </p>
<p>在es6中，提供了一种简洁的函数写法，我们称作“箭头函数”。</p>
<p>写法：函数名=(形参)=&gt;{……}     当函数体中只有一个表达式时，{}和return可以省略，当函数体中形参只有一个时，()可以省略。</p>
<p>特点：箭头函数中的this始终指向箭头函数定义时的离this最近的一个函数，如果没有最近的函数就指向window。</p>
<p>————————————————</p>
<p><strong>对象的扩展</strong></p>
<p><strong>·属性的简写</strong>。ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var foo = &apos;bar&apos;;</span><br><span class="line"></span><br><span class="line">var baz = &#123;foo&#125;;  //等同于  var baz = &#123;foo: foo&#125;;</span><br><span class="line"></span><br><span class="line">·方法的简写。省略冒号与function关键字。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var o = &#123;</span><br><span class="line"></span><br><span class="line">  method() &#123;</span><br><span class="line"></span><br><span class="line">    return &quot;Hello!&quot;;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line">var o = &#123;</span><br><span class="line"></span><br><span class="line">  method: function() &#123;</span><br><span class="line"></span><br><span class="line">    return &quot;Hello!&quot;;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>————————————————</p>
<p><strong>Object.keys()方法</strong></p>
<p>· 获取对象的所有属性名或方法名（不包括原形的内容），返回一个数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"></span><br><span class="line">var obj=&#123;name: &quot;john&quot;, age: &quot;21&quot;, getName: function () &#123; alert(this.name)&#125;&#125;;</span><br><span class="line"></span><br><span class="line">console.log(Object.keys(obj));    // [&quot;name&quot;, &quot;age&quot;, &quot;getName&quot;]</span><br><span class="line"></span><br><span class="line">console.log(Object.keys(obj).length);    //3 </span><br><span class="line"></span><br><span class="line">console.log(Object.keys([&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;]));    //[&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]</span><br><span class="line"></span><br><span class="line">console.log(Object.keys(&quot;abcdef&quot;));    //[&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]</span><br></pre></td></tr></table></figure>

<p>————————————————<br><strong>Object.assign ()</strong></p>
<p>该方法将多个原对象的属性和方法都合并到了目标对象上面。可以接收多个参数，第一个参数是目标对象，后面的都是源对象。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var target  = &#123;&#125;; //目标对象</span><br><span class="line"></span><br><span class="line">var source1 = &#123;name : &apos;ming&apos;, age: &apos;19&apos;&#125;; //源对象1</span><br><span class="line"></span><br><span class="line">var source2 = &#123;sex : &apos;女&apos;&#125;; //源对象2</span><br><span class="line"></span><br><span class="line">var source3 = &#123;sex : &apos;男&apos;&#125;; //源对象3，和source2中的对象有同名属性sex</span><br><span class="line"></span><br><span class="line">Object.assign(target,source1,source2,source3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(target);    //&#123;name : &apos;ming&apos;, age: &apos;19&apos;, sex: &apos;男&apos;&#125;</span><br></pre></td></tr></table></figure>

<p>for…of 循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var arr=[&quot;小林&quot;,&quot;小吴&quot;,&quot;小佳&quot;];</span><br><span class="line"></span><br><span class="line">for(var v of arr)&#123;</span><br><span class="line"></span><br><span class="line">    console.log(v);	</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*//小林 *</span><br><span class="line"></span><br><span class="line">*//小吴 *</span><br><span class="line"></span><br><span class="line">//小佳</span><br></pre></td></tr></table></figure>

<p>————————————————</p>
<p><strong>Promise对象</strong></p>
<p>Promise是异步编程的一种解决方案，将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</p>
<p>它有三种状态，分别是pending-进行中、resolved-已完成、rejected-已失败。</p>
<p>Promise 构造函数包含一个参数和一个带有 resolve（解析）和 reject（拒绝）两个参数的回调。在回调中执行一些操作（例如异步），如果一切都正常，则调用 resolve，否则调用 reject。对于已经实例化过的 promise 对象可以调用 promise.then() 方法，传递 resolve 和 reject 方法作为回调。then()方法接收两个参数：onResolve和onReject，分别代表当前 promise 对象在成功或失败时。</p>
<p>————————————————</p>
<p><strong>解构赋值</strong></p>
<p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>
<p>数组的解构赋值数组中的值会自动被解析到对应接收该值的变量中，数组的解构赋值要一一对应 如果有对应不上的就是undefined</p>
<p><strong>set数据结构（可用于快速去重）</strong></p>
<p>Set数据结构，类似数组。所有的数据都是唯一的，没有重复的值。它本身是一个构造函数。</p>
<p>属性和方法：</p>
<p>size 数据的长度</p>
<p>add() 添加某个值，返回 Set 结构本身。</p>
<p>delete() 删除某个值，返回一个布尔值，表示删除是否成功。</p>
<p>has() 查找某条数据，返回一个布尔值。</p>
<p>clear() 清除所有成员，没有返回值。</p>
<p>应用：数组去重。</p>
<p>————————————————</p>
<p><strong>Spread Operator 展开运算符(…)</strong><br><strong>字符串新增方法</strong></p>
<p><strong>class</strong></p>
<p><strong>ES6数组面试题</strong></p>
<p>forEach() 2.map() 3.filter() 4.reduce() 5.some() 6.every() 7.all()方法 </p>
<p><strong>ES6编程题</strong></p>
<ol>
<li><p>使用解构，实现两个变量的值的交换</p>
<p>[a,b] = [b,a];</p>
</li>
<li><p>数组 [1,2,3,4] 每一个元素的平方并组成新的数组。 </p>
</li>
</ol>
<p><strong>宏任务和微任务</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">宏任务：script(主程序代码) setTimeOut setInterVal setImmediate  I/O操作  UI渲染     requestAnimationFrame</span><br><span class="line"></span><br><span class="line">微任务：promise（原生） MutationObserver process.nextTick() mutation Object.observe</span><br><span class="line">顺序：先微后宏</span><br><span class="line">script(主程序代码)—&gt;process.nextTick—&gt;Promises…——&gt;setTimeout——&gt;setInterval——&gt;setImmediate——&gt; I/O——&gt;UI rendering</span><br></pre></td></tr></table></figure>



<h1 id="Vue框架"><a href="#Vue框架" class="headerlink" title="Vue框架"></a>Vue框架</h1><hr>
<p><strong>1、active-class是哪个组件的属性？嵌套路由怎么定义？</strong><br>答：vue-router模块的router-link组件。</p>
<p>*<em>2、怎么定义vue-router的动态路由？怎么获取传过来的动态参数？ *</em><br>答：在router目录下的index.js文件中，对path属性加上/:id。  使用router对象的params.id</p>
<p>*<em>3、vue-router有哪几种导航钩子？    *</em><br>答：三种，一种是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。第二种：组件内的钩子；第三种：单独路由独享组件</p>
<p><strong>4、scss是什么？</strong><br>答：预处理css，把css当前函数编写，定义变量,嵌套。 先装css-loader、node-sass、sass-loader等加载器模块，</p>
<p><strong>5、mint-ui是什么？怎么使用？说出至少三个组件使用方法？</strong></p>
<p>答：基于vue的前端组件库。npm安装，然后import样式和js，vue.use（mintUi）全局引入。在单个组件局部引入：import {Toast} from ‘mint-ui’。组件一：Toast(‘登录成功’)；组件二：mint-header；组件三：mint-swiper</p>
<p><strong>6、v-model是什么？怎么使用？ vue中标签怎么绑定事件？</strong></p>
<p>答：可以实现双向绑定，指令（v-class、v-for、v-if、v-show、v-on）。vue的model层的data属性。绑定事件：&lt;input @click=doLog() /&gt;</p>
<p><strong>自己实现 v-model 类似的效果？</strong>  1 给文本框绑定 value值  2 给文本框绑定 onchange或者oninput事件</p>
<p><strong>7、axios是什么？怎么使用？描述使用它实现登录功能的流程？</strong></p>
<p>答：请求后台资源的模块。npm install axios -S装好，然后发送的是跨域，需在配置文件中config/index.js进行设置。后台如果是Tp5则定义一个资源路由。js中使用import进来，然后.get或.post。返回在.then函数中如果成功，失败则是在.catch函数中</p>
<p><strong>8、axios+tp5进阶中，调用axios.post(‘api/user’)是进行的什么操作？axios.put(‘api/user/8′)呢？</strong></p>
<p>答：跨域，添加用户操作，更新操作。</p>
<p><strong>9、什么是RESTful API？怎么使用?</strong></p>
<p>我们平时都使用 get  post</p>
<p><strong>RESTful接口</strong>  :  使用的 get  post  put  delete 这些请求 不仅只有get post</p>
<p>答：是一个api的标准，无状态请求。请求的路由地址是固定的，如果是tp5则先路由配置中把资源路由配置好。标准有：.post .put .delete  .get</p>
<p>如果有一个地址  /api/all</p>
<p>.post(“ /api/all”)   .get(“ /api/all”)    .put(“ /api/all”)     .delete(“ /api/all”)</p>
<p><strong>10、vuex是什么？怎么使用？哪种功能场景使用它？</strong></p>
<p>答：vue框架中状态管理。在main.js引入store，注入。新建了一个目录store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车</p>
<p><strong>11、mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？</strong></p>
<p>答：一个model+view+viewModel框架，数据模型model，viewModel连接两个</p>
<p>区别：vue数据驱动，通过数据来显示视图层而不是节点操作。</p>
<p>场景：数据操作比较多的场景，更加便捷</p>
<p><strong>12、自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？</strong></p>
<p>答：全局定义指令：在vue对象的directive方法里面有两个参数，一个是指令名称，另外一个是函数。组件内定义指令：directives</p>
<p>钩子函数：bind（绑定事件触发）、inserted(节点插入的时候触发)、update（组件内相关更新）</p>
<p>钩子函数参数：el、binding</p>
<p><strong>13、说出至少4种vue当中的指令和它的用法？</strong></p>
<p>答：v-if：判断是否隐藏；v-for：数据循环出来；v-bind:class：绑定一个属性；v-model：实现双向绑定</p>
<p><strong>14、vue-router是什么？它有哪些组件？</strong></p>
<p>答：vue用来写路由一个插件。router-link、router-view</p>
<p><strong>15、导航钩子有哪些？它们有哪些参数？</strong></p>
<p>答：导航钩子有：a/全局钩子和组件内独享的钩子。b/beforeRouteEnter、afterEnter、beforeRouterUpdate、beforeRouteLeave</p>
<p>参数：有to（去的那个路由）、from（离开的路由）、next（一定要用这个函数才能去到下一个路由，如果不用就拦截）最常用就这几种</p>
<p><strong>16、Vue的双向数据绑定原理是什么？</strong></p>
<p>答：vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<p><strong>具体步骤：</strong></p>
<p><strong>第一步：需要observe的数据对象进行递归遍历</strong>，包括子属性对象的属性，都加上 setter和getter<br>这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</p>
<p><strong>第二步：compile解析模板指令</strong>，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p>
<p><strong>第三步：Watcher订阅者是Observer和Compile之间通信的桥梁</strong>，主要做的事情是:<br>1、在自身实例化时往属性订阅器(dep)里面添加自己<br>2、自身必须有一个update()方法<br>3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</p>
<p><strong>第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者</strong>，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p>
<p>ps：16题答案同样适合”<strong>vue data是怎么实现的？”</strong>此面试题<strong>。</strong></p>
<p><strong>17、请详细说下你对vue生命周期的理解？</strong></p>
<p>答：总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。</p>
<p><strong>创建前/后：</strong> 在beforeCreated阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el还没有。</p>
<p><strong>载入前/后：</strong>在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。</p>
<p><strong>更新前/后：</strong>当data变化时，会触发beforeUpdate和updated方法。</p>
<p><strong>销毁前/后：</strong>在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在</p>
<p><strong>18、请说下封装 vue 组件的过程？</strong>(<strong>看myvue的about组件的Swiper</strong>)</p>
<p>答：首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：<strong>效率低</strong>、<strong>难维护</strong>、<strong>复用性</strong>等问题。</p>
<p>使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。</p>
<p><strong>19、你是怎么认识vuex的？</strong></p>
<p>答：vuex可以理解为一种开发模式或框架。比如PHP有thinkphp，java有spring等。<br>通过状态（数据源）集中管理驱动组件的变化（好比spring的IOC容器对bean进行集中管理）。</p>
<p>应用级的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。</p>
<p><strong>20、vue-loader是什么？使用它的用途有哪些？</strong></p>
<p>答：解析.vue文件的一个加载器，跟template/js/style转换成js模块。</p>
<p>用途：js可以写es6、style样式可以scss或less、template可以加jade等</p>
<p><strong>21、请说出vue.cli项目中src目录每个文件夹和文件的用法？</strong></p>
<p>答：assets文件夹是放静态资源；components是放组件；router是定义路由相关的配置;view视图；app.vue是一个应用主组件；main.js是入口文件</p>
<p><strong>22、vue.cli中怎样使用自定义的组件？有遇到过哪些问题吗？</strong></p>
<p>答：第一步：在components目录新建你的组件文件（smithButton.vue），script一定要export default {</p>
<p>第二步：在需要用的页面（组件）中导入：import smithButton from ‘../components/smithButton.vue’</p>
<p>第三步：注入到vue的子组件的components属性上面,components:{smithButton}</p>
<p>第四步：在template视图view中使用，<smith-button>  </smith-button><br>问题有：smithButton命名，使用的时候则smith-button。</p>
<p><strong>23、聊聊你对Vue.js的template编译的理解？</strong></p>
<p>答：简而言之，就是先转化成 抽象语法树(AST)  js底层编译完成的，再得到的render函数返回VNode（Vue的虚拟DOM节点）</p>
<p>详情步骤：</p>
<p>首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。</p>
<p>然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等）</p>
<p><strong>****</strong>1、vue响应式原理？**</p>
<p>在实例化的过程中，通过Object.defineProperty()会对a.b添加getter和setter，同时Vue.js会对模板做编译，解析生成一个指令对象（这里是v-text指令），每个指令对象都会关联一个Watcher,当对a.b求值的时候，就会触发它的getter，当修改a.b的值的时候，就会触发它的setter，同时会通知被关联的Watcher，然后Watcher就会再次对a.b求值，计算对比新旧值，当值改变了，Watcher就会通知到指令，调用指令的update()方法，由于指令是对DOM的封装，所以就会调用DOM的原生方法去更新视图，这样就完成了数据改变到视图更新的一个自动过程</p>
<p><strong>2、vue-router实现原理？</strong></p>
<p>实现这一点主要是两种方式:</p>
<p>1.Hash: 通过改变hash值</p>
<p>2.History: 利用history对象新特性</p>
<p><strong>****</strong>3、为什么要选vue？与其它框架对比的优势和劣势？****</p>
<p>· Vue 最大优势就是它比较新颖，没历史包袱，它吸取了 React 和 Angular 的教训</p>
<p>· Vue轻量级，易上手，易学习</p>
<p>· Vue更加灵活，（比起 Angular）更少专制</p>
<p>· 组件（Component）是 Vue最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码</p>
<p><strong>****</strong>4、vue如何实现父子组件通信，以及非父子组件通信？<strong>**</strong></p>
<p><strong>父子通讯 可以通过props属性来实现</strong><br>父组件：<br>//这里必须要用 - 代替驼峰<br>data(){ return { msg: [1,2,3] }; }<br>子组件通过props来接收数据: 方式1：<br>props: [‘childMsg’]<br>方式2 :<br>props: { childMsg: Array //这样可以指定传入的类型，如果类型不对，会警告 }<br>方式3：<br>props: { childMsg: { type: Array, default: [0,0,0] //这样可以指定默认的值 } }<br>这样呢，就实现了父组件向子组件传递数据。</p>
<p><strong>子父通讯 事件$emit触发</strong></p>
<p> <strong>非父子通讯</strong></p>
<p>​     可以通过eventHub来实现通信. 所谓eventHub就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件.<br>let Hub = new Vue(); //创建事件中心<br>组件1触发：<br>methods: { eve() { Hub.$emit(‘change’,’hehe’); //Hub触发事件 } }<br>组件2接收:<br>created() { Hub.$on(‘change’, () =&gt; { //Hub接收事件 this.msg = ‘hehe’; }); }<br>这样就实现了非父子组件之间的通信了.原理就是把Hub当作一个中转站！</p>
<p><strong>**</strong>5、vuejs与angularjs以及react的区别？**</p>
<p><strong>与</strong>angularjs<strong>的区别：</strong></p>
<p><strong>1、Angular.js的学习成本高，比如增加了Dependency Injection特性，而Vue.js本身提供的API都比较简单、直观。</strong></p>
<p><strong>2、在性能上，Angular.js依赖对数据做脏检查，所以watcher越多越慢。</strong></p>
<p><strong>3、Vue.js使用基于依赖追踪的观察并且使用异步队列更新。所有的数据都是独立出发的。</strong></p>
<p><strong>对于庞大的应用来说，这个优化差异还是比较明显的。</strong></p>
<hr>
<p><strong>与reactjs的区别：</strong></p>
<p><strong>React 依赖Virtual DOM，而Vue.js使用的是DOM模板。React采用的Virtual DOM会对渲染出来的结果做脏检查。 <strong>**</strong></strong>Vue.js在模板中提供了指令，过滤器等，可以非常方便，快捷地操作Virtual DOM。**</p>
<hr>
<p><strong>6、vuex是用来做什么的？</strong></p>
<p>vuex可以理解为一种开发模式或框架。比如PHP有thinkphp，java有spring等。<br>通过状态（数据源）集中管理驱动组件的变化（好比spring的IOC容器对bean进行集中管理）。</p>
<p>应用级的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。</p>
<p><strong>组件中 data 为什么是函数</strong></p>
<blockquote>
<p>为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？</p>
</blockquote>
<p>因为组件是用来复用的，JS 里对象是引用关系，这样作用域没有隔离，而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。</p>
<p><strong>token–refresh token 一起 存着</strong>  </p>
<p>前端拿到token失效 就重新发送 refresh token 去刷新token 同时所有的请求可以放在一个观察者数组 后面再调用 避免失效的同时一直发送请求</p>
<p><strong>设计模式</strong></p>
<ol>
<li>单例模式 -  一个类对象 在内部只new 一次 其他时候都用这个  就不用重复new了</li>
<li>观察者模式– 给一个对象 用用来发布 和订阅    发布为主人 订阅的意思就是其他人来关注主人 (就是把很多 对象的方法 push到一个数组 后期发布只要循环数组调用 每个人都可以收到通知)   </li>
<li>工厂模式    — 一个对象 写上模板  后期其他类 可以继承他  实现批量生产 或者就是对象  调用一次出一个模板</li>
<li>职责链模式  —-将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。（大函数分割成一个个小函数，清晰，各司其职）</li>
<li>命令模式—不知道请求的接收者是谁，也不知道被请求的操作是什么  –只是单纯的听见某个命令 就做某件事</li>
</ol>
<p>.</p>
<p><strong>不定项选择题：</strong></p>
<p>· <strong>下列关于vue的组件说法不正确的是（  1  ）</strong></p>
<ol>
<li>不一定要写style</li>
<li>template视图里可以写多个div容器</li>
<li>父组件给子组件传值需定义props属性</li>
<li>子组件与父组件通信需定义$emit属性</li>
</ol>
<p><strong>· 下面关于vue的声明周期说法不正确的是（ 4 ）</strong></p>
<ol>
<li>总共分为8个阶段:创建前/后、载入前/后、更新前/后、销毁前/后、</li>
</ol>
<ol start="2">
<li>updated和beforeUpdate分别是更新完成和更新前</li>
</ol>
<ol start="3">
<li>创建后this才可以获取属性、mounted时$el节点才被渲染</li>
</ol>
<ol start="4">
<li>created创建后$el就不是undefined了</li>
</ol>
<p>· 下面关于js框架说法正确的是（1，2，3，4 ）</p>
<ol>
<li><strong>Vue是一个MVVM框架</strong></li>
<li><strong>Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件</strong></li>
<li>Vue中可以使用 v-for 指令来循环对象</li>
<li><strong>在 input 输入框中我们可以使用 v-model 指令来实现双向数据绑定</strong></li>
</ol>
<p><strong>vue3 有使用 proxy</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vue3</span><br><span class="line">利用的是原生es6语法  Reflect与Proxy是相辅相成的，在Proxy上有的方法，在Reflect就一定有</span><br><span class="line"></span><br><span class="line">Proxy用于修改某些操作的默认行为，也可以理解为在目标对象之前架设一层拦截，外部所有的访问都必须先通过这层拦截，因此提供了一种机制，可以对外部的访问进行过滤和修改。这个词的原理为代理，在这里可以表示由它来“代理”某些操作，译为“代理器”。</span><br><span class="line"></span><br><span class="line">var obj = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get: function (target, key, receiver) &#123;</span><br><span class="line">    console.log(`getting $&#123;key&#125;!`);</span><br><span class="line">    return Reflect.get(target, key, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  set: function (target, key, value, receiver) &#123;</span><br><span class="line">    console.log(`setting $&#123;key&#125;!`);</span><br><span class="line">    return Reflect.set(target, key, value, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>




            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls"
                data-autoplay="true">
                <source type="audio/mpeg" src="http://ef.sycdn.kuwo.cn/f709fbd132fed7c82045e82ee9fd6ff9/5e33883c/resource/n1/3/56/3990387546.mp3">
            </audio>
            
            
            
    <div id='gitalk-container' class="comment link"
        data-ae='true'
        data-ci='ec894e2b66f752e8b7fb'
        data-cs='3ccc2e92bb350688fe2c2dc2930189b62622bfb1'
        data-r='blog-comments'
        data-o='FloatingRain'
        data-a='FloatingRain'
        data-d=''
    >留言</div>


            
            
        </div>
        <div class="sidebar">
            <div class="box animated fadeInRight">
                <div class="subbox">
                    <img src="https://res.cloudinary.com/tridiamond/image/upload/v1573019751/TriDiamond_logo_ui_xeublz.jpg" height=300 width=300></img>
                    <p>Floating Rain</p>
                    <span>Floating Rain Blog</span>
                    <dl>
                        <dd><a href="https://github.com/kbzxzzm" target="_blank"><span
                                    class=" iconfont icon-github"></span></a></dd>
                        <dd><a href="https://gitee.com/kbzxzzm" target="_blank"><span
                                    class=" iconfont icon-twitter"></span></a></dd>
                        <dd><a href="https://stackoverflow.com/users/12817184/flioatingrain" target="_blank"><span
                                    class=" iconfont icon-stack-overflow"></span></a></dd>
                    </dl>
                </div>
                <ul>
                    <li><a href="/">15 <p>文章</p></a></li>
                    <li><a href="/categories">1 <p>分类</p></a></li>
                    <li><a href="/tags">1 <p>标签</p></a></li>
                </ul>
            </div>
            
            
            
            <div class="box sticky animated fadeInRight faster">
                <div id="toc" class="subbox">
                    <h4>目录</h4>
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-javascript-typeof返会的数据类型有哪些"><span class="toc-number">1.</span> <span class="toc-text">1. javascript typeof返会的数据类型有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-列举三种强制类型转换-显示转换-和两种隐式类型转换"><span class="toc-number">2.</span> <span class="toc-text">2. 列举三种强制类型转换(显示转换)和两种隐式类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-数组"><span class="toc-number">3.</span> <span class="toc-text">3. 数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-判断是否为数组的方法"><span class="toc-number">4.</span> <span class="toc-text">4. 判断是否为数组的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-pop-push-unshift-shift"><span class="toc-number">5.</span> <span class="toc-text">5. pop(),push(),unshift(),shift()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-DOM0-DOM2"><span class="toc-number">6.</span> <span class="toc-text">6. DOM0 DOM2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-IE678很多兼容问题-大家找两个记一下"><span class="toc-number">7.</span> <span class="toc-text">7. IE678很多兼容问题(大家找两个记一下 )</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-IE标准下有哪些兼容性写法"><span class="toc-number">8.</span> <span class="toc-text">8. IE标准下有哪些兼容性写法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-call-apply-bind"><span class="toc-number">9.</span> <span class="toc-text">9. call apply bind</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-构造函数"><span class="toc-number">10.</span> <span class="toc-text">10. 构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-如何阻止默认行为和事件冒泡"><span class="toc-number">11.</span> <span class="toc-text">11. 如何阻止默认行为和事件冒泡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-添加-删除-替换-插入到某个DOM节点的方法"><span class="toc-number">12.</span> <span class="toc-text">12. 添加 删除 替换 插入到某个DOM节点的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-window-onload和-document-ready的区别"><span class="toc-number">13.</span> <span class="toc-text">13. window.onload和$(document).ready的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-和-区别"><span class="toc-number">14.</span> <span class="toc-text">14. == 和 === 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-javascript的同源策略（跨域问题）"><span class="toc-number">15.</span> <span class="toc-text">15. javascript的同源策略（跨域问题）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-解决方法："><span class="toc-number">15.1.</span> <span class="toc-text">15.1. 解决方法：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-javascript是一种什么样的语言"><span class="toc-number">16.</span> <span class="toc-text">16. javascript是一种什么样的语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-javascript基本数据类型和引用数据类型-复杂类型"><span class="toc-number">17.</span> <span class="toc-text">17. javascript基本数据类型和引用数据类型(复杂类型)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-js原生不要与jq搞混"><span class="toc-number">18.</span> <span class="toc-text">18. js原生不要与jq搞混</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-DOM-BOM"><span class="toc-number">19.</span> <span class="toc-text">19. DOM,BOM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-null和undefind的区别"><span class="toc-number">20.</span> <span class="toc-text">20. null和undefind的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-XML和JSON的区别"><span class="toc-number">21.</span> <span class="toc-text">21. XML和JSON的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-前端存储"><span class="toc-number">22.</span> <span class="toc-text">22. 前端存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-哪些操作会造成内存泄露"><span class="toc-number">23.</span> <span class="toc-text">23. 哪些操作会造成内存泄露</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-js垃圾回收方式"><span class="toc-number">24.</span> <span class="toc-text">24. js垃圾回收方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-闭包"><span class="toc-number">25.</span> <span class="toc-text">25. 闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-this指向问题"><span class="toc-number">26.</span> <span class="toc-text">26. this指向问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-高阶函数"><span class="toc-number">27.</span> <span class="toc-text">27. 高阶函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-new操作符到底干了什么"><span class="toc-number">28.</span> <span class="toc-text">28. new操作符到底干了什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-js严格模式"><span class="toc-number">29.</span> <span class="toc-text">29. js严格模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-事件代理事件委托"><span class="toc-number">30.</span> <span class="toc-text">30. 事件代理事件委托</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-什么是版本控制，"><span class="toc-number">31.</span> <span class="toc-text">31.什么是版本控制，</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-ajax请求"><span class="toc-number">32.</span> <span class="toc-text">32.ajax请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-在浏览器中输入URL到整个页面显示在用户面前时这个过程中到底发生了什么"><span class="toc-number">33.</span> <span class="toc-text">33.在浏览器中输入URL到整个页面显示在用户面前时这个过程中到底发生了什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#详细："><span class="toc-number">33.1.</span> <span class="toc-text">详细：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-ajax和json"><span class="toc-number">34.</span> <span class="toc-text">34.ajax和json</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-http考点"><span class="toc-number">35.</span> <span class="toc-text">35.http考点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#常用的HTTP方法有哪些"><span class="toc-number">35.1.</span> <span class="toc-text">常用的HTTP方法有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GET与POST方法的区别"><span class="toc-number">35.2.</span> <span class="toc-text">GET与POST方法的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http请求报文与响应报文格式"><span class="toc-number">35.3.</span> <span class="toc-text">http请求报文与响应报文格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http状态码"><span class="toc-number">35.4.</span> <span class="toc-text">http状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http缺点与https"><span class="toc-number">35.5.</span> <span class="toc-text">http缺点与https</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#es6"><span class="toc-number"></span> <span class="toc-text">es6</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue框架"><span class="toc-number"></span> <span class="toc-text">Vue框架</span></a>
                </div>
            </div>
            
            
        </div>
    </div>
</div>

    </div>
</div>
    <div id="back-to-top" class="animated fadeIn faster">
        <div class="flow"></div>
        <span class="percentage animated fadeIn faster">0%</span>
        <span class="iconfont icon-top02 animated fadeIn faster"></span>
    </div>
</body>
<footer>
    <p class="copyright" id="copyright">
        &copy; 2020
        <span class="gradient-text">
            Floating Rain
        </span>.
        Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a>
        Theme
        <span class="gradient-text">
            <a href="https://github.com/kbzxzzm" title="FloatingRain" target="_blank" rel="noopener">FloatingRain</a>
        </span>
        <small><a href="https://github.com/TriDiamond/hexo-theme-obsidian/blob/master/CHANGELOG.md" title="v1.4.3" target="_blank" rel="noopener">v1.4.3</a></small>
    </p>
</footer>

<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
    "HTML-CSS": {
      preferredFont: "TeX",
      availableFonts: ["STIX", "TeX"],
      linebreaks: {
        automatic: true
      },
      EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
      inlineMath: [
        ["$", "$"],
        ["\\(", "\\)"]
      ],
      processEscapes: true,
      ignoreClass: "tex2jax_ignore|dno",
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      noUndefined: {
        attributes: {
          mathcolor: "red",
          mathbackground: "#FFEEEE",
          mathsize: "90%"
        }
      },
      Macros: {
        href: "{}"
      }
    },
    messageStyle: "none"
  });
</script>
<script>
  function initialMathJax() {
    MathJax.Hub.Queue(function () {
      var all = MathJax.Hub.getAllJax(),
        i;
      // console.log(all);
      for (i = 0; i < all.length; i += 1) {
        console.log(all[i].SourceElement().parentNode)
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  }

  function reprocessMathJax() {
    if (typeof MathJax !== 'undefined') {
      MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
    }
  }
</script>



    <link rel="stylesheet" href="//cdn.bootcss.com/gitalk/1.5.0/gitalk.min.css">
    <script src="//cdn.bootcss.com/gitalk/1.5.0/gitalk.min.js"></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/obsidian.js"></script>
<script src="/js/jquery.truncate.js"></script>
<script src="/js/search.js"></script>
<script src="//cdn.bootcss.com/typed.js/2.0.10/typed.min.js"></script>
<script src="//cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>

<script src="https://cdn.bootcss.com/codemirror/5.48.4/codemirror.min.js"></script>

    <script src="//cdn.bootcss.com/codemirror/5.48.4/mode/javascript/javascript.min.js"></script>

    <script src="//cdn.bootcss.com/codemirror/5.48.4/mode/css/css.min.js"></script>

    <script src="//cdn.bootcss.com/codemirror/5.48.4/mode/xml/xml.min.js"></script>

    <script src="//cdn.bootcss.com/codemirror/5.48.4/mode/htmlmixed/htmlmixed.min.js"></script>

    <script src="//cdn.bootcss.com/codemirror/5.48.4/mode/clike/clike.min.js"></script>

    <script src="//cdn.bootcss.com/codemirror/5.48.4/mode/php/php.min.js"></script>

    <script src="//cdn.bootcss.com/codemirror/5.48.4/mode/shell/shell.min.js"></script>

    <script src="//cdn.bootcss.com/codemirror/5.48.4/mode/python/python.min.js"></script>



    <script src="/js/busuanzi.min.js"></script>
    <script>
        $(document).ready(function () {
            if ($('span[id^="busuanzi_"]').length) {
                initialBusuanzi();
            }
        });
    </script>


<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="//www.googletagmanager.com/gtag/js?id=UA-149874671-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-149874671-1');
    </script>





<script>
    function initialTyped () {
        var typedTextEl = $('.typed-text');
        if (typedTextEl && typedTextEl.length > 0) {
            var typed = new Typed('.typed-text', {
                strings: ["Floating Rain Blog", "浮  雨  个  人  博  客"],
                typeSpeed: 90,
                loop: true,
                loopCount: Infinity,
                backSpeed: 20,
            });
        }
    }

    if ($('.article-header') && $('.article-header').length) {
        $(document).ready(function () {
            initialTyped();
        });
    }
</script>




</html>
